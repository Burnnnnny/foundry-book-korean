## EIP-712 서명 구현 및 테스트

Foundry는 EIP-712 서명을 쉽고 안정적으로 작업할 수 있는 여러 유틸리티를 제공합니다.

EIP-712는 타입이 지정된 구조화된 데이터를 해싱하고 서명하기 위한 표준입니다. 불투명한 해시에 서명하는 대신 사용자는 사람이 읽을 수 있는 메시지에 서명할 수 있어 사용성과 보안이 크게 향상됩니다. 이는 메타 트랜잭션, 허가 함수(ERC-20 permit 등) 및 기타 오프체인 서명 체계에 특히 유용합니다. 그러나 EIP-712 해싱 로직을 올바르게 구현하는 것은 복잡할 수 있습니다. Foundry 제품군은 개발자가 확신을 가지고 EIP-712 구현을 테스트하고 검증할 수 있도록 특별히 설계된 강력한 유틸리티를 제공합니다.

이 가이드에서는 Uniswap의 Permit2 시스템에서 가져온 `PermitHash.sol`과 같은 복잡한 라이브러리를 검증하는 방법을 보여주는 실제 예제를 통해 Foundry의 EIP-712 명령어와 치트코드를 활용하는 방법을 보여줍니다. 이를 통해 사용자 정의 EIP-712 해싱 구현이 표준과 완벽하게 일치하는지 확인하는 방법을 보여줍니다.

## EIP-712 명령어

Forge는 EIP-712 타입을 작업할 때 유용한 몇 가지 명령어를 제공합니다:

### forge eip712

터미널에 대상 파일 내 구조체의 표준(canonical) 타입 정의를 출력합니다.

:::tip
`forge eip712` 명령어를 사용하여 표준 타입 정의를 생성하고 컨트랙트에 수동으로 복사-붙여넣기하세요. 이렇게 하면 오타를 방지할 수 있습니다.
:::

### forge bind-json

대상 파일의 구조체에 대한 Solidity 바인딩을 자동으로 생성합니다.
생성된 바인딩은 JSON 문자열로 쉽게 직렬화하거나 JSON 문자열에서 파싱할 수 있습니다.
또한 이러한 바인딩을 통해 EIP-712 치트코드는 이름만으로 타입 정의를 파생시킬 수 있습니다.

## EIP-712 치트코드

Foundry는 EIP-712 타입과 상호 작용하기 위한 여러 치트코드를 제공합니다:

#### vm.eip712HashType

- EIP-712 구조체 정의에 대한 `typeHash`를 생성합니다. 이는 표준 타입 인코딩의 `keccak256`입니다.
- 직접 문자열 정의(예: `"Mail(address from,string contents)"`)를 받거나, `forge bind-json`을 사용하여 Solidity 구조체에서 바인딩을 생성한 경우 타입 이름을 받을 수 있습니다.

#### vm.eip712HashStruct

- `structHash`를 계산합니다: `keccak256(typeHash + encodeData(struct))`.
- `encodeData(struct)`는 구조체 멤버의 ABI 인코딩된 값입니다.
- `vm.eip712HashType`과 마찬가지로 직접 타입 정의 문자열이나 타입 이름(바인딩 포함)을 허용합니다.

#### vm.eip712HashTypedData

- 서명할 최종 EIP-712 다이제스트를 생성합니다: `keccak256("\x19\x01" + domainSeparator + structHash)`.
- EIP-712 사양에 따라 타입이 지정된 데이터를 나타내는 전체 JSON 문자열을 받습니다. 서명 검증의 엔드투엔드 테스트에 유용합니다.

### Uniswap의 `PermitHash` 라이브러리 테스트

Uniswap의 `Permit2` 시스템은 `PermitHash.sol` 라이브러리를 활용하여 다양한 permit 구조에 대해 EIP-712 표준을 준수하는 해시를 생성합니다. 이 가이드에서는 Foundry를 사용하여 라이브러리가 EIP-712 해싱 규칙을 올바르게 구현하는지 검증하는 방법을 보여줍니다.

우리의 목표는 `PermitHash.sol` 내의 몇 가지 해싱 함수에 집중하는 것입니다. 이 함수들에 샘플 데이터를 제공한 다음, 동일한 데이터와 표준 EIP-712 타입 정의를 사용하여 `vm.eip712HashStruct`를 실행하고 생성된 해시가 일치하는지 확인합니다.

### 테스트 환경 설정

검증을 시작하기 전에 `PermitHash.t.sol` 테스트 파일을 생성해야 합니다.

```solidity
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.17;

import "forge-std/Test.sol";
// 테스트할 라이브러리 임포트
import {PermitHash} from "src/libraries/PermitHash.sol";
import {IAllowanceTransfer as IAT} from "src/interfaces/IAllowanceTransfer.sol";

/* 다음은 `PermitHash`가 의존하는 `IAT`에 정의된 구조체입니다:

struct PermitDetails {
  address token;
  uint160 amount;
  uint48 expiration;
  uint48 nonce;
}

struct PermitSingle {
  PermitDetails details;
  address spender;
  uint256 sigDeadline;
}
*/
```

> **팁:** 앞서 설명한 대로 `forge bind-json`을 사용하여 Foundry의 기능을 활용하면 테스트 시 더 높은 보장을 받을 수 있습니다. 해당 명령어를 실행하면 EIP-712 치트코드를 사용할 때 단순히 구조체 이름을 사용할 수 있으며, Foundry가 자동으로 표준 타입 정의를 파생시킵니다.

### `typeHash` 검증

먼저 각 구조체에 대한 타입 해시가 올바른지 확인합니다:

```solidity
contract PermitHashTest is Test {
  function test_validatePermitDetails_typeHash() public {
    // 이 테스트는 `forge json`에 의해 생성된 바인딩에 의존하지 않으므로,
    // 치트코드 입력으로 타입의 문자열 표현이 필요합니다.

    // Uniswap 라이브러리에서 사용할 수 있다고 가정합니다. 그렇지 않으면 수동으로 복사-붙여넣기해야 합니다.
    string memory _PERMIT_DETAILS_TYPEDEF =
      "PermitDetails(address token,uint160 amount,uint48 expiration,uint48 nonce)";

    // Uniswap 라이브러리에 정의된 타입 해시 상수
    bytes32 typeHash = PermitHash._PERMIT_DETAILS_TYPEHASH;

    // 치트코드를 사용하여 예상 해시 가져오기 (문자열 표현 사용)
    bytes32 expected = vm.eip712HashType(_PERMIT_DETAILS_TYPEDEF);

    assertEq(typeHash, expected, "PermitDetails typeHash mismatch");
  }

  function test_validatePermitSingle_typeHash() public {
    // Uniswap 라이브러리에 정의된 타입 해시 상수
    bytes32 typeHash = PermitHash._PERMIT_SINGLE_TYPEHASH;

    // 치트코드를 사용하여 예상 해시 가져오기 (바인딩 필요)
    bytes32 expected = vm.eip712HashType("PermitSingle");

    assertEq(typeHash, expected, "PermitSingle typeHash mismatch");
  }
}
```

:::note
라이브러리의 `typeHash`에 결함이 있다면 치트코드에 대한 어설션이 이를 드러낼 것입니다.
:::

### `structHash` 검증

타입 정의의 해시가 올바른지 확인한 후, 구조체의 해시가 EIP-712 사양을 따르는지 검증해 보겠습니다.

```solidity
contract PermitHashTest is Test {
  address TOKEN = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
  address SPENDER = 0xdEADBEeF00000000000000000000000000000000;

  function test_validatePermitDetails_structHash() public {
    // 이 테스트는 `forge bind-json`에 의해 생성된 바인딩에 의존하지 않으므로,
    // 치트코드 입력으로 타입의 문자열 표현이 필요합니다.

    // Uniswap 라이브러리에서 사용할 수 있다고 가정합니다. 그렇지 않으면 수동으로 복사-붙여넣기해야 합니다.
    string memory _PERMIT_DETAILS_TYPEDEF =
      "PermitDetails(address token,uint160 amount,uint48 expiration,uint48 nonce)";

    // PermitDetails에 대한 테스트 데이터 준비
    IAllowanceTransfer.PermitDetails memory details = IAllowanceTransfer.PermitDetails({
      token: TOKEN,
      amount: 100 ether,
      expiration: uint48(block.timestamp + 3600),
      nonce: 123
    });

    // Uniswap 라이브러리에서 structHash 가져오기.
    // private이지만 public 함수로 사용할 수 있다고 가정합니다.
    bytes32 structHash = PermitHash._hashPermitDetails(details);

    // 치트코드를 사용하여 예상 해시 가져오기 (문자열 표현 사용)
    bytes32 expected = vm.eip712HashStruct(_PERMIT_DETAILS_TYPEDEF, abi.encode(details));

    assertEq(structHash, expected, "PermitDetails structHash mismatch");
  }

  function test_validatePermitSingle_structHash() public {
    IAT.PermitDetails memory details = IAT.PermitDetails({
      token: TOKEN,
      amount: 200 ether,
      expiration: uint48(block.timestamp + 7200),
      nonce: 456
    });

    IAT.PermitSingle memory permitSingle = IAT.PermitSingle({
      details: details,
      spender: SPENDER,
      sigDeadline: block.timestamp + 10800
    });

    // Uniswap 라이브러리에서 structHash 가져오기.
    bytes32 structHash = PermitHash.hash(permitSingle);

    // 치트코드를 사용하여 예상 해시 가져오기 (바인딩 필요)
    bytes32 expectedStructHash = vm.eip712HashStruct("PermitSingle", abi.encode(permitSingle));

    assertEq(structHash, expected, "PermitSingle structHash mismatch");
  }
}
```

:::note
라이브러리의 `structHash`에 결함이 있다면 치트코드에 대한 어설션이 이를 드러낼 것입니다.
:::
