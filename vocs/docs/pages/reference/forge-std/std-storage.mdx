## Std 스토리지 (Std Storage)

Std 스토리지는 스토리지를 쉽게 조작할 수 있게 해주는 라이브러리입니다.

Std 스토리지를 사용하려면 테스트 컨트랙트에서 다음을 임포트하세요:

```solidity
import {stdStorage, StdStorage} from "forge-std/Test.sol";
```

테스트 컨트랙트에 다음 줄을 추가하세요:

```solidity
using stdStorage for StdStorage;
```

그런 다음 `stdstore` 인스턴스를 통해 Std 스토리지에 액세스하세요.

### 함수

쿼리 함수:

- [`target`](/reference/forge-std/target.mdx): 대상 컨트랙트의 주소 설정
- [`sig`](/reference/forge-std/sig.mdx): 정적 호출(static call)할 함수의 4바이트 선택자 설정
- [`with_key`](/reference/forge-std/with_key.mdx): 함수에 인수 전달 (여러 번 사용 가능)
- [`depth`](/reference/forge-std/depth.mdx): `tuple` 내 값의 위치 설정 (예: `struct` 내부)
- [`enable_packed_slots`](/reference/forge-std/enable_packed_slots.mdx): 패킹된 스토리지 슬롯 사용 허용

종결 함수:

- [`find`](/reference/forge-std/find.mdx): 슬롯 번호 반환
- [`checked_write`](/reference/forge-std/checked_write.mdx): 스토리지 슬롯에 쓸 데이터 설정
- [`read_<type>`](/reference/forge-std/read.mdx): 스토리지 슬롯에서 값을 `<type>`으로 읽기

### 간단한 예시

`playerToCharacter`는 플레이어의 캐릭터 정보를 추적합니다.

```solidity
// MetaRPG.sol

struct Character {
    string name;
    uint256 level;
}

mapping (address => Character) public playerToCharacter;
```

캐릭터의 레벨을 120으로 설정하고 싶다고 가정해 봅시다.

```solidity
// MetaRPG.t.sol

stdstore
    .target(address(metaRpg))
    .sig("playerToCharacter(address)")
    .with_key(address(this))
    .depth(1)
    .checked_write(120);
```

### 패킹된 슬롯 예시 (Packed-Slot Example)

`balanceOf()`는 가스 최적화된 ERC20 구현에서 사용자의 잔액을 반환합니다.
`enable_packed_slots()`는 아래 예시와 같이 [ERC7201 네임스페이스 스토리지 슬롯](https://eips.ethereum.org/EIPS/eip-7201), 프록시 패턴 및 패킹된 슬롯에서도 작동합니다:

````solidity
// AgoraDollar.sol
contract AgoraDollar {
    /// @notice The Erc20AccountData struct
    /// @param isFrozen A boolean to indicate if the account is frozen
    /// @param balance A uint248 to store the balance of the account
    struct Erc20AccountData {
        bool isFrozen;
        uint248 balance;
    }

    /// @notice The Erc20CoreStorage struct
    /// @param accountData A mapping of address to Erc20AccountData to store account data
    /// @custom:storage-location erc7201:AgoraDollarErc1967Proxy.Erc20CoreStorage
    struct Erc20CoreStorage {
        /// @dev _account The account whose data we are accessing
        /// @dev _accountData The account data for the account
        mapping(address _account => Erc20AccountData _accountData) accountData;
    }

    /// @notice The ```ERC20_CORE_STORAGE_SLOT_``` is the storage slot for the Erc20CoreStorage struct
    /// @dev keccak256(abi.encode(uint256(keccak256("AgoraDollarErc1967Proxy.Erc20CoreStorage")) - 1)) & ~bytes32(uint256(0xff))
    bytes32 internal constant ERC20_CORE_STORAGE_SLOT_ =
        0x455730fed596673e69db1907be2e521374ba893f1a04cc5f5dd931616cd6b700;

    /// @notice The ```getPointerToErc20CoreStorage``` function returns a pointer to the Erc20CoreStorage struct
    /// @return $ A pointer to the Erc20CoreStorage struct
    function getPointerToErc20CoreStorage() internal pure returns (Erc20CoreStorage storage $) {
        /// @solidity memory-safe-assembly
        assembly {
            $.slot := ERC20_CORE_STORAGE_SLOT_
        }
    }

    /// @notice The ```balanceOf``` function returns the token balance of a given account
    /// @param _account The account to check the balance of
    /// @return The balance of the account
    function balanceOf(address _account) external view returns (uint256) {
        return getPointerToErc20CoreStorage().accountData[_account].balance;
    }
}
````

AUSD 컨트랙트에서 주소의 잔액을 어떤 금액으로 설정하는 함수를 원한다고 가정해 봅시다.

```solidity
// TestAgoraDollar.t.sol

function seedUserWithAusd(address _to, uint248 _amount) internal {
    stdstore
        .enable_packed_slots()
        .target(address(Constants.Mainnet.AUSD_ERC20)) //0x00000000eFE302BEAA2b3e6e1b18d08D69a9012a
        .sig("balanceOf(address)")
        .with_key(_to)
        .checked_write(_amount);
}
```

### 알려진 문제

- `tuple`이 32바이트보다 짧은 타입을 포함하는 경우 슬롯을 찾지 못할 수 있습니다.
