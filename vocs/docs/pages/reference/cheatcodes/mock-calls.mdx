## `mockCalls`

### 시그니처

```solidity
function mockCalls(address where, bytes calldata data, bytes[] calldata retdata) external;
```

```solidity
function mockCalls(
    address where,
    uint256 value,
    bytes calldata data,
    bytes[] calldata retdata
) external;
```

### 설명

호출 데이터가 `data`와 엄격하게 또는 느슨하게 일치하는 경우 `where` 주소에 대한 모든 호출을 모의(Mock)하고 `retdata` 배열 값을 기반으로 각 호출에 대해 서로 다른 데이터를 반환합니다.

호출 모의 및 일치 우선순위에 대한 자세한 내용은 [`mockCall`](/reference/cheatcodes/mock-call.mdx)을 참조하세요.

> ℹ️ **참고**
>
> `retdata`의 요소 수를 초과하는 모의 호출은 응답으로 마지막 `retdata` 요소를 받습니다.
> `clearMockedCalls`를 호출하여 모의를 지울 수 있습니다.

### 예제

여러 `balanceOf(address)` 호출 모의:

```solidity
function testMockCall() public {
    bytes[] memory mocks = new bytes[](2);
    mocks[0] = abi.encode(2 ether);
    mocks[1] = abi.encode(1 ether);

    vm.mockCalls(
        address(0),
        abi.encodeWithSelector(IERC20.balanceOf.selector, address(1)),
        mocks
    );

    assertEq(IERC20(address(0)).balanceOf(address(1)), 2 ether);
    assertEq(IERC20(address(0)).balanceOf(address(1)), 1 ether);
}
```

`msg.value`로 여러 호출 모의:

```solidity
function testMockCallsWithMsgValue() public {
    bytes[] memory mocks = new bytes[](2);
    mocks[0] = abi.encode(2 ether);
    mocks[1] = abi.encode(1 ether);

    vm.mockCalls(
        address(0),
        1 ether,
        abi.encodeWithSelector(DexPool.swapETHForToken.selector),
        mocks
    );

    uint tokenAmount1 = DexPool(address(0)).swapETHForToken{value: 1 ether}();
    uint tokenAmount2 = DexPool(address(0)).swapETHForToken{value: 1 ether}();

    assertEq(tokenAmount1, 2 ether);
    assertEq(tokenAmount2, 1 ether);
}
```
