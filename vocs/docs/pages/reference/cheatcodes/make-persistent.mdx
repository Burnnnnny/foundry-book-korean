## `makePersistent`

### 시그니처

```solidity
function makePersistent(address account) external;
function makePersistent(address account0, address account1) external;
function makePersistent(address account0, address account1, address account2) external;
function makePersistent(address[] calldata accounts) external;
```

### 설명

각 포크([`createFork`](/reference/cheatcodes/create-fork.mdx))는 독립적인 스토리지를 가지며, 다른 포크가 선택되면([`selectFork`](/reference/cheatcodes/select-fork.mdx)) 교체됩니다.
기본적으로 테스트 컨트랙트 계정과 호출자(caller)만 포크 간에 영구적입니다. 즉, 테스트 컨트랙트의 상태(변수) 변경 사항은 다른 포크가 선택되어도 보존됩니다. 이를 통해 데이터를 컨트랙트 변수에 저장하여 공유할 수 있습니다.

그러나 이 치트코드를 사용하면 지정된 계정을 영구적으로 표시하여 현재 활성 포크와 관계없이 상태를 사용할 수 있습니다.

### 예제

새 컨트랙트를 영구적으로 표시하기

```solidity
contract SimpleStorageContract {
    string public value;

    function set(uint256 _value) public {
        value = _value;
    }
}

function testMarkPersistent() public {
    // 기본적으로 `sender`와 컨트랙트 자체는 영구적입니다.
    assert(cheats.isPersistent(msg.sender));
    assert(cheats.isPersistent(address(this)));

    // 특정 포크 선택
    cheats.selectFork(mainnetFork);

    // `mainnetFork` 스토리지에 저장된 새 컨트랙트 생성
    SimpleStorageContract simple = new SimpleStorageContract();

    // `simple`은 영구적으로 표시되지 않음
    assert(!cheats.isPersistent(address(simple)));

    // 컨트랙트 사용 가능
    uint256 expectedValue = 99;
    simple.set(expectedValue);
    assertEq(simple.value(), expectedValue);

    // 영구적으로 표시
    cheats.makePersistent(address(simple));

    // 다른 포크 선택
    cheats.selectFork(optimismFork);

    // 컨트랙트가 여전히 영구적인지 확인
    assert(cheats.isPersistent(address(simple)));

    // 값이 예상대로 설정되어 있음
    assertEq(simple.value(), expectedValue);
}
```

### 같이 보기

- [isPersistent](/reference/cheatcodes/is-persistent.mdx)
- [revokePersistent](/reference/cheatcodes/revoke-persistent.mdx)
- [createFork](/reference/cheatcodes/create-fork.mdx)
- [selectFork](/reference/cheatcodes/select-fork.mdx)
