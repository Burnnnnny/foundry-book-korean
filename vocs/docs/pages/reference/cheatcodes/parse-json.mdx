## `parseJson`

### 시그니처

```solidity
// Return the value(s) that correspond to 'key'
vm.parseJson(string memory json, string memory key)
// Return the entire JSON file
vm.parseJson(string memory json);
```

### 설명

이 치트코드들은 문자열 형태의 JSON 파일을 구문 분석(파싱)하는 데 사용됩니다. 일반적으로 전체 파일을 문자열 형태로 반환하는 `vm.readFile()`과 함께 사용됩니다.

더 나은 UX를 위해 `forge-std`의 `stdJson` 헬퍼 라이브러리를 사용할 수 있습니다.

이 치트코드는 JSON에서 특정 값을 검색하기 위한 `key`를 받거나, 키 없이 전체 JSON을 반환합니다. 값은 abi-인코딩된 `bytes` 배열로 반환됩니다. 즉, 올바르게 작동하려면 `abi.decode()`를 사용하여 적절한 타입으로 디코딩해야 하며, 그렇지 않으면 `revert` 됩니다.

### JSONpath 키

`parseJson`은 JSONpath라는 구문을 사용하여 임의의 JSON 파일에 대한 임의의 키를 형성합니다. 동일한 구문(또는 방언)이 [`jq`](https://stedolan.github.io/jq/) 도구에서 사용됩니다.

구문에 대해 더 자세히 알고 싶다면, 이 기능을 구현하기 위해 내부적으로 사용하는 Rust 라이브러리의 [README](https://crates.io/crates/jsonpath-rust)를 방문할 수 있습니다. 이를 통해 올바른 jsonPath 방언을 사용하고 있는지 확인할 수 있습니다.

### JSON 인코딩 규칙

[JSON 사양](https://www.w3schools.com/js/js_json_datatypes.asp)에 정의된 대로 `number`, `string`, `object`, `array`, `boolean`, `null` 용어를 사용합니다.

**인코딩 규칙**

- `null`은 `bytes32(0)`으로 인코딩됩니다.
- 0보다 크거나 같은 숫자는 `uint256`으로 인코딩됩니다.
- 음수는 `int256`으로 인코딩됩니다.
- 소수점이 있는 부동 소수점 숫자는 허용되지 않습니다.
- 과학적 표기법을 사용하는 부동 소수점 숫자는 값에 따라 `uint256` 또는 `int256`이 될 수 있습니다.
- `H160` 타입으로 디코딩할 수 있고 `0x`로 시작하는 문자열은 `address`로 인코딩됩니다. 즉, 주소로 디코딩할 수 있다면 아마도 주소일 것입니다.
- `0x`로 시작하는 문자열은 길이가 `66`이면 `bytes32`로, 그렇지 않으면 `bytes`로 인코딩됩니다.
- `address`, `bytes32`, 또는 `bytes`가 아닌 문자열은 `string`으로 인코딩됩니다.
- 배열은 첫 번째 요소의 타입을 따르는 동적 배열로 인코딩됩니다.
- 객체(`{}`)는 `tuple`로 인코딩됩니다.

### 타입 강제 변환 (Type Coercion)

위에서 설명한 대로, `parseJson`은 JSON 값의 타입을 추론해야 하며 여기에는 몇 가지 내재적인 한계가 있습니다. 이러한 이유로 반환된 값의 타입을 강제하는 `parseJson*` 치트코드 하위 제품군이 있습니다.

예를 들어 `vm.parseJsonUint(json, key)`는 값을 `uint256`으로 강제 변환합니다. 즉, 다음 모든 값을 구문 분석하여 `uint256`으로 반환할 수 있습니다. 여기에는 `number` 타입의 숫자, `string`으로 된 숫자, 그리고 16진수 표현이 포함됩니다.

```json
{
  "hexUint": "0x12C980",
  "stringUint": "115792089237316195423570985008687907853269984665640564039457584007913129639935",
  "numberUint": 115792089237316195423570985008687907853269984665640564039457584007913129639935
}
```

마찬가지로 모든 타입( `bytes` 및 `bytes32` 포함)과 해당 배열(`vm.parseJsonUintArray`)에 대한 치트코드가 있습니다.

### JSON 객체를 Solidity 구조체로 디코딩

JSON 객체는 튜플로 인코딩되며 튜플이나 구조체를 통해 디코딩할 수 있습니다. 즉, Solidity에서 `struct`를 정의하면 전체 JSON 객체를 해당 `struct`로 디코딩할 수 있습니다.

예를 들어:

다음 JSON:

```json
{
  "a": 43,
  "b": "sigma"
}
```

은 다음으로 디코딩됩니다:

```solidity
struct Json {
    uint256 a;
    string b;
}
```

값은 abi-인코딩된 튜플로 반환되므로 구조체 속성의 정확한 이름은 JSON의 키 이름과 일치할 필요가 없습니다. 위의 json 파일은 다음과 같이 디코딩될 수도 있습니다:

```solidity
struct Json {
    uint256 apple;
    string pineapple;
}
```

중요한 것은 알파벳 순서입니다. JSON 객체는 순서가 없는 데이터 구조이지만 튜플은 순서가 있는 구조이므로 JSON에 어떤 순서를 부여해야 했습니다. 가장 쉬운 방법은 키를 알파벳 순서로 정렬하는 것이었습니다. 즉, JSON 객체를 올바르게 디코딩하려면 JSON 키의 알파벳 순서 값에 해당하는 **타입**으로 구조체의 속성을 정의해야 합니다.

- 구조체는 직렬로 해석됩니다. 즉, 튜플의 첫 번째 항목은 구조체 정의의 첫 번째 항목을 기반으로 디코딩됩니다(알파벳 순서 아님).
- JSON은 직렬이 아닌 알파벳 순서로 구문 분석됩니다.
- 이 구문 분석은 내부적으로 Rust의 BTreeMap 크레이트를 사용하므로 대문자와 소문자 문자열이 다르게 처리됩니다. 사전식 순서에서 대문자가 소문자보다 *앞서*므로 "Zebra"가 "apple"보다 앞에 옵니다.

따라서 JSON의 (알파벳 순서로) 첫 번째 값은 abi-인코딩된 다음 `struct`의 첫 번째 속성 타입을 기반으로 abi-디코딩을 시도합니다.

위의 JSON은 아래 구조체로 디코딩할 수 없습니다:

```solidity
struct Json {
    uint256 b;
    uint256 a;
}
```

이유는 문자열 `"sigma"`를 uint로 디코딩하려고 시도하기 때문입니다. 정확히 말하면 디코딩되지만 바이트를 잘못 해석하기 때문에 잘못된 숫자가 됩니다.

또 다른 예로, 다음 JSON이 주어지면:

```json
{
  "apples": [
    {
      "sweetness": 7,
      "sourness": 3,
      "color": "Red"
    },
    {
      "sweetness": 5,
      "sourness": 5,
      "color": "Green"
    },
    {
      "sweetness": 9,
      "sourness": 1,
      "color": "Yellow"
    }
  ],
  "name": "Fresh Fruit"
}
```

Solidity 구조체는 다음과 같이 정의됩니다:

```solidity
struct Apple {
    string color;
    uint8 sourness;
    uint8 sweetness;
}

struct FruitStall {
    Apple[] apples;
    string name;
}
```

다음과 같이 JSON을 디코딩할 수 있습니다:

```solidity
string memory root = vm.projectRoot();
string memory path = string.concat(root, "/src/test/fixtures/fruitstall.json");
string memory json = vm.readFile(path);
bytes memory data = vm.parseJson(json);
FruitStall memory fruitstall = abi.decode(data, (FruitStall));

// Logs: Welcome to Fresh Fruit
console2.log("Welcome to", fruitstall.name);

for (uint256 i = 0; i < fruitstall.apples.length; i++) {
    Apple memory apple = fruitstall.apples[i];

    // Logs:
    // Color: Red, Sourness: 3, Sweetness: 7
    // Color: Green, Sourness: 5, Sweetness: 5
    // Color: Yellow, Sourness: 1, Sweetness: 9
    console2.log(
        "Color: %s, Sourness: %d, Sweetness: %d",
        apple.color,
        apple.sourness,
        apple.sweetness
    );
}
```

### JSON 객체 디코딩 팁

JSON 객체에 `hex numbers`가 있는 경우 바이트로 인코딩됩니다. 더 나은 UX를 위해 이를 `uint`로 디코딩하는 방법은 두 개의 `struct`를 정의하는 것입니다. 하나는 이러한 값을 `bytes`로 정의하는 중간 구조체이고, 다른 하나는 사용자가 사용할 최종 `struct`입니다.

1. JSON을 중간 `struct`로 디코딩합니다.
2. `bytes`를 `uint`로 변환하여 중간 구조체를 최종 구조체로 변환합니다. `forge-std`에는 이를 수행하는 헬퍼 함수가 있습니다.
3. 최종 `struct`를 사용자에게 제공합니다.

### StdJson 사용 방법

1. 라이브러리 가져오기: `import {stdJson} from "forge-std/StdJson.sol";`
2. `string`에 대한 사용 정의: `using stdJson for string;`
3. 단순 값(숫자, 주소 등)을 구문 분석하려면 헬퍼 함수를 사용하세요.
4. 전체 JSON 객체를 구문 분석하려면:
   1. Solidity에서 `struct`를 정의합니다. 알파벳 순서를 따르도록 주의하세요. 디버깅하기 어렵습니다.
   2. `parseRaw()` 헬퍼 함수를 사용하여 abi-인코딩된 `bytes`를 반환한 다음 구조체로 디코딩하세요.

```solidity
string memory root = vm.projectRoot();
string memory path = string.concat(root, "/src/test/fixtures/broadcast.log.json");
string memory json = vm.readFile(path);
bytes memory transactionDetails = json.parseRaw(".transactions[0].tx");
RawTx1559Detail memory rawTxDetail = abi.decode(transactionDetails, (RawTx1559Detail));
```

### Forge 스크립트 아티팩트

우리는 forge 스크립트 브로드캐스팅에서 아티팩트를 읽기 위해 몇 가지 헬퍼 구조체와 함수를 만들었습니다.

현재 우리는 EIP1559 호환 체인에서 생성된 아티팩트만 지원하며 아직 전체 `broadcast.json` 아티팩트의 구문 분석을 지원하지 **않습니다**. `transactions`, `receipts` 등과 같은 개별 값을 구문 분석해야 합니다.

트랜잭션을 읽으려면 다음과 같이 하면 됩니다:

```solidity
function testReadEIP1559Transactions() public {
    string memory root = vm.projectRoot();
    string memory path = string.concat(root, "/src/test/fixtures/broadcast.log.json");
    Tx1559[] memory transactions = readTx1559s(path);
}
```

그런 다음 이러한 구조체의 다양한 필드에 액세스할 수 있습니다:

```solidity
struct Tx1559 {
    string[] arguments;
    address contractAddress;
    string contractName;
    string functionSig;
    bytes32 hash;
    Tx1559Detail txDetail;
    string opcode;
}

struct Tx1559Detail {
    AccessList[] accessList;
    bytes data;
    address from;
    uint256 gas;
    uint256 nonce;
    address to;
    uint256 txType;
    uint256 value;
}
```

### 문제 해결

#### 파일을 읽을 수 없음

> FAIL. Reason: The path `<file-path>` is not allowed to be accessed for read operations

이 오류가 발생하면 [`fs_permissions` 키](/reference/cheatcodes/fs.mdx)를 사용하여 `foundry.toml`에서 읽기 권한을 활성화했는지 확인하세요.

### 참고

- 헬퍼 라이브러리: [stdJson.sol](https://github.com/foundry-rs/forge-std/blob/master/src/StdJson.sol)
- 사용 예제: [stdCheats.t.sol](https://github.com/foundry-rs/forge-std/blob/ca8d6e00ea9cb035f6856ff732203c9a3c48b966/src/test/StdCheats.t.sol#L206)
- [파일 치트코드](/reference/cheatcodes/fs.mdx): 파일 작업을 위한 치트코드
