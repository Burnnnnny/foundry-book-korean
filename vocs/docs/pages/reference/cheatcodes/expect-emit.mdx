## `expectEmit`

### 서명

```solidity
function expectEmit() external;
```

```solidity
function expectEmit(
    bool checkTopic1,
    bool checkTopic2,
    bool checkTopic3,
    bool checkData
) external;
```

```solidity
function expectEmit(address emitter) external;
```

```solidity
function expectEmit(
    bool checkTopic1,
    bool checkTopic2,
    bool checkTopic3,
    bool checkData,
    address emitter
) external;
```

### 설명

다음 호출 중에 특정 로그가 발생(emit)한다고 어설션합니다.

1. 치트 코드를 호출하여 첫 번째, 두 번째 또는 세 번째 토픽과 로그 데이터(`expectEmit()`은 모두 확인함)를 확인해야 하는지 여부를 지정합니다. 토픽 0은 항상 확인됩니다.
2. 다음 호출 중에 보게 될 이벤트를 발생시킵니다.
3. 호출을 수행합니다.

다음 호출에서 이벤트의 _시퀀스_ 와 일치하도록 1단계와 2단계를 여러 번 수행할 수 있습니다.

이벤트를 현재 범위에서 사용할 수 없는 경우(예: 인터페이스나 외부 스마트 컨트랙트를 사용하는 경우) 동일한 이벤트 서명으로 이벤트를 직접 정의할 수 있습니다.

`expectEmit`에는 2가지 종류가 있습니다:

- **발행자 주소를 확인하지 않음**: 발행 주소를 확인하지 **않고** 토픽이 일치하는지 어설션합니다.
- **`address` 사용**: 토픽이 일치하고 발행 주소가 일치하는지 어설션합니다.

> ℹ️ **시퀀스 일치**
>
> 많은 이벤트를 발생시키는 함수에서는 이벤트를 "건너뛰고" 특정 시퀀스만 일치시키는 것이 가능하지만, 이 시퀀스는 항상 순서대로 있어야 합니다. 예를 들어, 
> 함수가 `A, B, C, D, E, F, F, G` 이벤트를 발생시킨다고 가정해 봅시다.
>
> `expectEmit`은 그 사이의 이벤트를 건너뛰거나 건너뛰지 않고 범위를 일치시킬 수 있습니다:
> - `[A, B, C]`는 유효합니다.
> - `[B, D, F]`는 유효합니다.
> - `[G]` 또는 다른 단일 이벤트 조합은 유효합니다.
> - `[B, A]` 또는 유사한 순서가 잘못된 조합은 **유효하지 않습니다** (이벤트는 순서대로 있어야 함).
> - `[C, F, F]`는 유효합니다.
> - `[F, F, C]`는 **유효하지 않습니다** (순서가 잘못됨).

### 예제

이것은 발행 주소를 확인하지 않습니다.

```solidity
event Transfer(address indexed from, address indexed to, uint256 amount);

function testERC20EmitsTransfer() public {
    vm.expectEmit();

    // 우리가 볼 것으로 예상되는 이벤트를 발생시킵니다.
    emit MyToken.Transfer(address(this), address(1), 10);

    // 호출을 수행합니다.
    myToken.transfer(address(1), 10);
}
```

이것은 발행 주소를 확인합니다.

```solidity
event Transfer(address indexed from, address indexed to, uint256 amount);

function testERC20EmitsTransfer() public {
    // 주소를 전달하여 토큰이 이벤트 발행자임을 확인합니다.
    vm.expectEmit(address(myToken));
    emit MyToken.Transfer(address(this), address(1), 10);

    // 호출을 수행합니다.
    myToken.transfer(address(1), 10);
}
```

단일 호출에서 여러 이벤트가 발생한다고 어설션할 수도 있습니다.

```solidity
function testERC20EmitsBatchTransfer() public {
    // 여러 예상 전송 이벤트를 선언합니다
    for (uint256 i = 0; i < users.length; i++) {
        // 여기서는 데모 목적으로 더 긴 서명을 사용합니다. 이 호출은
        // topic0 (항상 확인됨), topic1 (true), topic2 (true), NOT topic3 (false), 그리고 data (true)를 확인합니다.
        vm.expectEmit(true, true, false, true);
        emit Transfer(address(this), users[i], 10);
    }

    // 또한 사용자 정의 `BatchTransfer(uint256 numberOfTransfers)` 이벤트를 예상합니다.
    vm.expectEmit(false, false, false, true);
    emit BatchTransfer(users.length);

    // 호출을 수행합니다.
    myToken.batchTransfer(users, 10);
}
```

이 예제는 예상 이벤트가 다음 호출에서 발생하지 않으므로 실패합니다.
```solidity
event Transfer(address indexed from, address indexed to, uint256 amount);

function testERC20EmitsTransfer() public {
    // 다섯 번째 인수로 주소를 전달하여 토큰이 이벤트 발행자임을 확인합니다.
    vm.expectEmit(true, true, false, true, address(myToken));
    emit MyToken.Transfer(address(this), address(1), 10);

    // 의도된 이벤트를 발생시키지 않는 관련 없는 호출을 수행하여
    // 치트코드가 실패하게 만듭니다.
    myToken.approve(address(this), 1e18);
    // 호출을 수행하지만 치트코드가 이미 실패했으므로 효과가 없습니다.
    myToken.transfer(address(1), 10);
}
```
