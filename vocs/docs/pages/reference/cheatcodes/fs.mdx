## 파일 치트코드

### 서명

```solidity
// 파일의 전체 내용을 문자열로 읽습니다, (path) => (data)
function readFile(string calldata) external returns (string memory);
/// 파일의 전체 내용을 바이너리로 읽습니다. `path`는 프로젝트 루트에 상대적입니다.
function readFileBinary(string calldata path) external view returns (bytes memory data);
/// 주어진 경로의 디렉토리를 `maxDepth`까지 재귀적으로 읽습니다.
/// `maxDepth`의 기본값은 1이며, 이는 주어진 디렉토리의 직접적인 자식만 반환됨을 의미합니다.
/// `followLinks`가 true이면 심볼릭 링크를 따릅니다.
function readDir(string calldata path) external view returns (DirEntry[] memory entries);
// 파일의 다음 줄을 문자열로 읽습니다, (path) => (line)
function readLine(string calldata) external returns (string memory);
/// 심볼릭 링크를 읽어 링크가 가리키는 경로를 반환합니다.
/// 이 치트코드는 다음과 같은 상황에서 리버트되지만 이에 국한되지 않습니다:
/// - `path`가 심볼릭 링크가 아닙니다.
/// - `path`가 존재하지 않습니다.
function readLink(string calldata linkPath) external view returns (string memory targetPath);
// 데이터를 파일에 씁니다. 파일이 존재하지 않으면 생성하고, 존재하면 내용을 완전히 덮어씁니다.
// (path, data) => ()
function writeFile(string calldata, string calldata) external;
// 줄을 파일에 씁니다. 파일이 존재하지 않으면 생성합니다.
// (path, data) => ()
function writeLine(string calldata, string calldata) external;
// 읽기 위해 파일을 닫고 오프셋을 재설정하여 readLine으로 처음부터 다시 읽을 수 있게 합니다.
// (path) => ()
function closeFile(string calldata) external;
// 파일을 제거합니다. 이 치트코드는 다음과 같은 상황에서 리버트되지만 이에 국한되지 않습니다:
/// - 경로가 디렉토리를 가리킵니다.
/// - 파일이 존재하지 않습니다.
/// - 사용자가 파일을 제거할 권한이 없습니다.
// (path) => ()
function removeFile(string calldata) external;
// 주어진 경로가 기존 엔티티를 가리키면 true를 반환하고, 그렇지 않으면 false를 반환합니다.
// (path) => (bool)
function exists(string calldata) external returns (bool);
// 경로가 디스크에 존재하고 일반 파일을 가리키면 true를 반환하고, 그렇지 않으면 false를 반환합니다.
// (path) => (bool)
function isFile(string calldata) external returns (bool);
// 경로가 디스크에 존재하고 디렉토리를 가리키면 true를 반환하고, 그렇지 않으면 false를 반환합니다.
// (path) => (bool)
function isDir(string calldata) external returns (bool);
```

### 설명

[forge-std](https://github.com/foundry-rs/forge-std)에서 제공하는 이 치트코드들은 파일 시스템 조작 작업에 사용할 수 있습니다.

기본적으로 파일 시스템 액세스는 허용되지 않으며 `foundry.toml`에 `fs_permissions` 설정이 필요합니다:

```toml
# `vm.writeFile`과 같이 파일 시스템을 건드리는 치트코드에 대한 권한을 구성합니다.
# `access`는 치트코드를 통해 `path`에 액세스하는 방법을 제한합니다.
#    `read-write` | `true`   => `read` + `write` 액세스 허용 (`vm.readFile` + `vm.writeFile`)
#    `none`| `false` => 액세스 없음
#    `read` => 읽기 액세스만 허용 (`vm.readFile`)
#    `write` => 쓰기 액세스만 허용 (`vm.writeFile`)
# `allowed_paths`는 고려되는 경로를 추가로 나열합니다. 예: `./`는 프로젝트 루트 디렉토리를 나타냅니다.
# 기본적으로 fs 액세스 권한이 _부여되지 않으며_, 경로가 _허용되지 않습니다_.
# 다음 예시는 프로젝트 디렉토리에 대해서만 읽기 액세스를 활성화합니다:
#       `fs_permissions = [{ access = "read", path = "./"}]`
fs_permissions = [] # default: all file cheat codes are disabled
```

### 예시

파일에 줄 추가, 파일이 아직 존재하지 않으면 생성합니다.

파일 / 프로젝트 루트에 대한 읽기 권한이 필요합니다.

```toml
fs_permissions = [{ access = "read", path = "./"}]
```

```solidity
string memory path = "output.txt";

string memory line1 = "first line";
vm.writeLine(path, line1);

string memory line2 = "second line";
vm.writeLine(path, line2);
```

파일에 쓰고 읽기

파일 / 프로젝트 루트에 대한 읽기-쓰기 권한이 필요합니다:

```toml
fs_permissions = [{ access = "read-write", path = "./"}]
```

```solidity
string memory path = "file.txt";
string memory data = "hello world";
vm.writeFile(path, data);

assertEq(vm.readFile(path), data);
```

파일 제거

파일 / 프로젝트 루트에 대한 쓰기 권한이 필요합니다:

```toml
fs_permissions = [{ access = "write", path = "./"}]
```

```solidity
string memory path = "file.txt";
vm.removeFile(path);

assertFalse(vm.exists(validPath));
```

파일 시스템 경로가 유효한지 확인

```solidity
// 경로 'foo/files/bar.txt'가 존재하는지 확인
string memory validPath = "foo/files/bar.txt";
assertTrue(vm.exists(validPath));
```

파일 시스템 경로가 파일 또는 디렉토리를 가리키는지 확인

```solidity
// 경로 'foo/file/bar.txt'가 파일을 가리키는지 확인
string memory validFilePath = "foo/files/bar.txt";
assertTrue(vm.isFile(validFilePath));

// 'foo/file'이 디렉토리를 가리키는지 확인
string memory validDirPath = "foo/files";
assertTrue(vm.isDir(validDirPath));
```
