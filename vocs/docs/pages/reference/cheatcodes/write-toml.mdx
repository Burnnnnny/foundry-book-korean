## `writeToml`

### 시그니처

```solidity
function writeToml(string calldata json, string calldata path) external;

function writeToml(string calldata json, string calldata path, string calldata valueKey) external;
```

### 설명

변환 후 직렬화된 JSON 객체를 TOML 파일에 씁니다.

`json` 인수는 문자열화된 형태의 JSON 객체여야 합니다. 예를 들어:

```text
{ "boolean": true, "number": 342, "object": { "title": "finally json serialization" } }
```

이것은 주로 [serializeJson](/reference/cheatcodes/serialize-json.mdx)을 통해 빌드됩니다.

`path` 인수는 쓸 TOML 파일의 경로입니다.

`valueKey`가 제공되지 않으면 TOML 객체가 새 파일에 기록됩니다. 파일이 이미 존재하는 경우 덮어씁니다.

`valueKey`가 제공되면 파일이 이미 존재해야 하며 유효한 TOML 파일이어야 합니다. 해당 파일의 객체는 TOML 변환 후 _JSON 경로_ `valueKey`의 값을 JSON 객체 `json`으로 대체하여 업데이트됩니다.

이것은 먼저 파싱한 다음 다시 직렬화할 필요 없이 TOML 파일의 일부 값을 교체하는 데 유용합니다. 지정된 키 또는 JSON 경로의 중간 키가 존재하지 않으면 생성됩니다.

**기억하세요:** 파일 경로 `path`는 허용된 경로에 있어야 합니다. 자세한 내용은 [파일 치트코드](/reference/cheatcodes/fs.mdx)를 읽어보세요.

#### JSON 경로

`valueKey` 매개변수는 JSON 구조에서 값을 배치하거나 업데이트할 위치를 지정하기 위해 JSONPath 구문을 사용합니다. Foundry는 내부적으로 [jsonpath_lib](https://docs.rs/jsonpath_lib/latest/jsonpath_lib/) 라이브러리를 사용하여 이러한 경로를 파싱합니다.

다음 JSON 객체를 고려해 봅시다:

```json
{
  "boolean": true,
  "number": 342,
  "obj1": {
    "aNumber": 123,
    "obj2": {
      "aNumber": 123,
      "obj3": {
        "veryDeep": 13371337
      }
    }
  }
}
```

**중요:** JSON 경로가 올바르게 작동하려면 형식이 적절해야 합니다:

- **루트 객체 가정**: 루트 객체는 항상 가정되므로 경로는 점(`.`)이나 달러 기호(`$`)로 시작해야 합니다.
- **점 표기법**: 루트 수준 속성에 액세스하려면 `.boolean`, `.number`, `.obj1`을 사용하세요.
- **중첩 액세스**: 구조 깊이 들어가려면 `.obj1.aNumber` 또는 `.obj1.obj2.aNumber`를 사용하세요.
- **자손 검색**: `.obj1..veryDeep` 또는 그냥 `..veryDeep`과 같이 하위 트리 어디에서나 키를 검색하려면 `..keyName`을 사용하세요.

**일반적인 실수**: `"key.foo"`와 같이 맨 키 이름을 사용하면 JSONPath 파서에 의해 `"$key.foo"`로 자동 변환되며, 이는 `key.foo`라는 루트 속성을 찾기 때문에 실패합니다. 대신 `".key.foo"` 또는 `"$.key.foo"`를 사용하세요.

유효한 경로 예:

- `.boolean` - 루트 수준에서 부울 속성에 액세스
- `$.boolean` - 명시적 루트 표기법을 사용하여 위와 동일
- `.obj1.aNumber` - 중첩 속성에 액세스
- `.obj1..veryDeep` - obj1 내 어디에서나 veryDeep 찾기
- `..veryDeep` - 문서 어디에서나 veryDeep 찾기

예제를 통해 실제로 확인해 보세요.

### 예제

#### 간단한 예제

```solidity
string memory jsonObj = '{ "boolean": true, "number": 342, "myObject": { "title": "finally json serialization" } }';
vm.writeToml(jsonObj, "./output/example.toml");

// `myObject`의 값을 새 객체로 대체
string memory newJsonObj = '{ "aNumber": 123, "aString": "asd" }';
vm.writeToml(newJsonObj, "./output/example.toml", ".myObject");

// 새 객체에서 `aString`의 값을 대체
vm.writeToml("my new string", "./output/example.toml", ".myObject.aString");

// Here's example.toml:
//
// boolean = true
// number = 342
//
// [myObject]
// aNumber = 123
// aString = "my new string"
```

#### 더 복잡한 예제

```solidity
string memory jsonObj = '{ "boolean": true, "number": 342, "obj1": { "foo": "bar" } }';
vm.writeToml(jsonObj, "./output/example2.toml");

string memory jsonObj2 = '{ "aNumber": 123, "obj2": {} }';
vm.writeToml(jsonObj2, "./output/example2.toml", ".obj1");

string memory jsonObj3 = '{ "aNumber": 123, "obj3": { "veryDeep": 3 } }';
vm.writeToml(jsonObj3, "./output/example2.toml", ".obj1.obj2");

// Here's example2.toml so far:
//
// boolean = true
// number = 342
//
// [obj1]
// aNumber = 123
//
// [obj1.obj2]
// aNumber = 123
//
// [obj1.obj2.obj3]
// veryDeep = 3

// 이 경우 JSON 객체는 단지 값 13371337입니다.
vm.writeToml("13371337", "./output/example2.toml", "..veryDeep");

// Here's the final example2.toml:
//
// boolean = true
// number = 342
//
// [obj1]
// aNumber = 123
//
// [obj1.obj2]
// aNumber = 123
//
// [obj1.obj2.obj3]
// veryDeep = 13371337
```

### 같이 보기

- [serializeJson](/reference/cheatcodes/serialize-json.mdx)
