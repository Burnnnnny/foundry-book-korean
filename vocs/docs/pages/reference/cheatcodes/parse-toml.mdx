## `parseToml`

### 시그니처

```solidity
// 'key'에 해당하는 값(들) 반환
vm.parseToml(string memory toml, string memory key)
// 전체 TOML 파일 반환
vm.parseToml(string memory toml);
```

### 설명

이 치트코드들은 문자열 형태의 TOML 파일을 JSON으로 변환한 후 구문 분석(파싱)하는 데 사용됩니다. 일반적으로 전체 파일을 문자열 형태로 반환하는 `vm.readFile()`과 함께 사용됩니다.

더 나은 UX를 위해 `forge-std`의 `stdToml` 헬퍼 라이브러리를 사용할 수 있습니다.

이 치트코드는 TOML에서 특정 값을 검색하기 위한 `key`를 받거나, 키 없이 전체 TOML을 반환합니다. 값은 abi-인코딩된 `bytes` 배열로 반환됩니다. 즉, 올바르게 작동하려면 `abi.decode()`를 사용하여 적절한 타입으로 디코딩해야 하며, 그렇지 않으면 `revert` 됩니다.

### JSONpath 키

`parseToml`은 JSONpath라는 구문을 사용하여 임의의 JSON 파일에 대한 임의의 키를 형성합니다. 동일한 구문(또는 방언)이 [`jq`](https://stedolan.github.io/jq/) 도구에서 사용됩니다.

구문에 대해 더 자세히 알고 싶다면, 이 기능을 구현하기 위해 내부적으로 사용하는 Rust 라이브러리의 [README](https://crates.io/crates/jsonpath-rust)를 방문할 수 있습니다. 이를 통해 올바른 jsonPath 방언을 사용하고 있는지 확인할 수 있습니다.

### 인코딩 규칙

[TOML 사양](https://www.w3schools.io/file/toml-datatypes/)에 정의된 대로 `string`, `integer`, `float`, `boolean`, `array`, `datetime`, `inline-table` 용어를 사용합니다.

[JSON 사양](https://www.w3schools.com/js/js_json_datatypes.asp)에 정의된 대로 `number`, `string`, `object`, `array`, `boolean`, `null` 용어를 사용합니다.

**TOML 인코딩 규칙**

- `float`는 32비트(예: `+1.5`)로 제한됩니다. 정밀도 손실을 방지하기 위해 문자열을 사용하는 것이 좋습니다.
- `integer`는 64비트(예: `9223372036854775807`)로 제한됩니다. 큰 값을 인코딩하려면 문자열을 사용하는 것이 좋습니다.
- 배열 값은 혼합된 타입을 가질 수 없습니다(예: `[256, "b"]` 불가, `[256, 512]` 또는 `["a", "b"]`만 가능).
- `datetime`은 변환 시 `string`으로 인코딩됩니다.
- `float`는 변환 시 `number`로 인코딩됩니다.
- `integer`는 변환 시 `number`로 인코딩됩니다.
- `inline-table` (또는 `table`)은 변환 시 `object`로 인코딩됩니다.
- `null`은 `"null"` 문자열로 인코딩됩니다.

**JSON 인코딩 규칙**

- `null`은 `bytes32(0)` 또는 `""`으로 인코딩됩니다.
- 0보다 크거나 같은 숫자는 `uint256`으로 인코딩됩니다.
- 음수는 `int256`으로 인코딩됩니다.
- 소수점이 있는 부동 소수점 숫자는 허용되지 않습니다.
- 과학적 표기법을 사용하는 부동 소수점 숫자는 값에 따라 `uint256` 또는 `int256`이 될 수 있습니다.
- `H160` 타입으로 디코딩할 수 있고 `0x`로 시작하는 문자열은 `address`로 인코딩됩니다. 즉, 주소로 디코딩할 수 있다면 아마도 주소일 것입니다.
- `0x`로 시작하는 문자열은 길이가 `66`이면 `bytes32`로, 그렇지 않으면 `bytes`로 인코딩됩니다.
- `address`, `bytes32`, 또는 `bytes`가 아닌 문자열은 `string`으로 인코딩됩니다.
- 배열은 첫 번째 요소의 타입을 따르는 동적 배열로 인코딩됩니다.
- 객체(`{}`)는 `tuple`로 인코딩됩니다.

### 타입 강제 변환 (Type Coercion)

위에서 설명한 대로, `parseToml`은 TOML 값의 타입을 추론해야 하며 여기에는 몇 가지 내재적인 한계가 있습니다. 이러한 이유로 반환된 값의 타입을 강제하는 `parseToml*` 치트코드 하위 제품군이 있습니다.

예를 들어 `vm.parseTomlUint(toml, key)`는 값을 `uint256`으로 강제 변환합니다. 즉, 다음 모든 값을 구문 분석하여 `uint256`으로 반환할 수 있습니다. 여기에는 `number` 타입의 숫자, `string`으로 된 숫자, 그리고 16진수 표현이 포함됩니다.

```toml
hexUint = "0x12C980"
stringUint = "115792089237316195423570985008687907853269984665640564039457584007913129639935"
numberUint = 9223372036854775807 # TOML은 64비트 정수로 제한됩니다.
```

마찬가지로 모든 타입( `bytes` 및 `bytes32` 포함)과 해당 배열(`vm.parseTomlUintArray`)에 대한 치트코드가 있습니다.

### TOML 테이블을 Solidity 구조체로 디코딩

TOML 테이블은 JSON 객체로 변환됩니다. JSON 객체는 튜플로 인코딩되며 튜플이나 구조체를 통해 디코딩할 수 있습니다. 즉, Solidity에서 `struct`를 정의하면 전체 JSON 객체를 해당 `struct`로 디코딩할 수 있습니다.

예를 들어:

다음 TOML:

```toml
a = 43
b = "sigma"
```

은 다음 JSON으로 변환됩니다:

```json
{
  "a": 43,
  "b": "sigma"
}
```

그리고 다음으로 디코딩됩니다:

```solidity
struct Json {
    uint256 a;
    string b;
}
```

값은 abi-인코딩된 튜플로 반환되므로 구조체 속성의 정확한 이름은 JSON의 키 이름과 일치할 필요가 없습니다. 위의 json 파일은 다음과 같이 디코딩될 수도 있습니다:

```solidity
struct Json {
    uint256 apple;
    string pineapple;
}
```

중요한 것은 알파벳 순서입니다. JSON 객체는 순서가 없는 데이터 구조이지만 튜플은 순서가 있는 구조이므로 JSON에 어떤 순서를 부여해야 했습니다. 가장 쉬운 방법은 키를 알파벳 순서로 정렬하는 것이었습니다. 즉, JSON 객체를 올바르게 디코딩하려면 JSON 키의 알파벳 순서 값에 해당하는 **타입**으로 구조체의 속성을 정의해야 합니다.

- 구조체는 직렬로 해석됩니다. 즉, 튜플의 첫 번째 항목은 구조체 정의의 첫 번째 항목을 기반으로 디코딩됩니다(알파벳 순서 아님).
- JSON은 직렬이 아닌 알파벳 순서로 구문 분석됩니다.
- 이 구문 분석은 내부적으로 Rust의 BTreeMap 크레이트를 사용하므로 대문자와 소문자 문자열이 다르게 처리됩니다. 사전식 순서에서 대문자가 소문자보다 *앞서*므로 "Zebra"가 "apple"보다 앞에 옵니다.

따라서 JSON의 (알파벳 순서로) 첫 번째 값은 abi-인코딩된 다음 `struct`의 첫 번째 속성 타입을 기반으로 abi-디코딩을 시도합니다.

위의 TOML은 아래 구조체로 디코딩할 수 없습니다:

```solidity
struct Json {
    uint256 b;
    uint256 a;
}
```

이유는 문자열 `"sigma"`를 uint로 디코딩하려고 시도하기 때문입니다. 정확히 말하면 디코딩되지만 바이트를 잘못 해석하기 때문에 잘못된 숫자가 됩니다.

또 다른 예로, 다음 TOML이 주어지면:

```toml
name = "Fresh Fruit"

[[apples]]
sweetness = 7
sourness = 3
color = "Red"

[[apples]]
sweetness = 5
sourness = 5
color = "Green"

[[apples]]
sweetness = 9
sourness = 1
color = "Yellow"
```

다음 JSON으로 변환됩니다:

```json
{
  "apples": [
    {
      "sweetness": 7,
      "sourness": 3,
      "color": "Red"
    },
    {
      "sweetness": 5,
      "sourness": 5,
      "color": "Green"
    },
    {
      "sweetness": 9,
      "sourness": 1,
      "color": "Yellow"
    }
  ],
  "name": "Fresh Fruit"
}
```

Solidity 구조체는 다음과 같이 정의됩니다:

```solidity
struct Apple {
    string color;
    uint8 sourness;
    uint8 sweetness;
}

struct FruitStall {
    Apple[] apples;
    string name;
}
```

다음과 같이 TOML을 디코딩할 수 있습니다:

```solidity
string memory root = vm.projectRoot();
string memory path = string.concat(root, "/src/test/fixtures/fruitstall.toml");
string memory toml = vm.readFile(path);
bytes memory data = vm.parseToml(toml);
FruitStall memory fruitstall = abi.decode(data, (FruitStall));

// Logs: Welcome to Fresh Fruit
console2.log("Welcome to", fruitstall.name);

for (uint256 i = 0; i < fruitstall.apples.length; i++) {
    Apple memory apple = fruitstall.apples[i];

    // Logs:
    // Color: Red, Sourness: 3, Sweetness: 7
    // Color: Green, Sourness: 5, Sweetness: 5
    // Color: Yellow, Sourness: 1, Sweetness: 9
    console2.log(
        "Color: %s, Sourness: %d, Sweetness: %d",
        apple.color,
        apple.sourness,
        apple.sweetness
    );
}
```

### StdToml 사용 방법

1. 라이브러리 가져오기: `import {stdToml} from "forge-std/StdToml.sol";`
2. `string`에 대한 사용 정의: `using stdToml for string;`
3. 단순 값(숫자, 주소 등)을 구문 분석하려면 헬퍼 함수를 사용하세요.
4. 전체 TOML 테이블을 구문 분석하려면:
   1. Solidity에서 `struct`를 정의합니다. 알파벳 순서를 따르도록 주의하세요. 디버깅하기 어렵습니다.
   2. `parseRaw()` 헬퍼 함수를 사용하여 abi-인코딩된 `bytes`를 반환한 다음 구조체로 디코딩하세요.

```solidity
string memory root = vm.projectRoot();
string memory path = string.concat(root, "/src/test/fixtures/config.toml");
string memory toml = vm.readFile(path);
bytes memory data = toml.parseRaw(".");
Config memory config = abi.decode(data, (Config))
```

### 문제 해결

#### 파일을 읽을 수 없음

> FAIL. Reason: The path `<file-path>` is not allowed to be accessed for read operations

이 오류가 발생하면 [`fs_permissions` 키](/reference/cheatcodes/fs.mdx)를 사용하여 `foundry.toml`에서 읽기 권한을 활성화했는지 확인하세요.

### 참고

- 헬퍼 라이브러리: [stdToml.sol](https://github.com/foundry-rs/forge-std/blob/master/src/StdToml.sol)
- [파일 치트코드](/reference/cheatcodes/fs.mdx): 파일 작업을 위한 치트코드
