## `expectRevert`

### 서명

```solidity
function expectRevert() external;
```

```solidity
function expectRevert(bytes4 revertData) external;
```

```solidity
function expectRevert(bytes4 revertData, address reverter) external;
```

```solidity
function expectRevert(bytes4 revertData, uint64 count) external;
```

```solidity
function expectRevert(bytes4 revertData, address reverter, uint64 count) external;
```

```solidity
function expectRevert(bytes calldata revertData) external;
```

```solidity
function expectRevert(bytes calldata revertData, address reverter) external;
```

```solidity
function expectRevert(bytes calldata revertData, uint64 count) external;
```

```solidity
function expectRevert(bytes calldata revertData, address reverter, uint64 count) external;
```

```solidity
function expectRevert(address reverter) external;
```

```solidity
function expectRevert(uint64 count) external;
```

```solidity
function expectRevert(address reverter, uint64 count) external;
```

```solidity
function expectPartialRevert(bytes4 revertData) external;
```

```solidity
function expectPartialRevert(bytes4 revertData, address reverter) external;
```

### 오류

> ❌ **오류**
>
> 다음 오류가 표시되는 경우:
>
> `[FAIL: call didn't revert at a lower depth than cheatcode call depth]`
>
> 다음 섹션을 주의 깊게 읽으십시오!

이 오류가 발생하는 이유를 이해하려면 먼저 `call depth`(호출 깊이)가 무엇을 의미하는지 이해해야 합니다.

호출 깊이를 함수 스코핑과 유사하게 생각할 수 있습니다. **외부(external)** 호출에 들어가면 호출 깊이가 `1` 증가합니다.
외부 호출을 종료하면 호출 깊이가 `1` 감소합니다. 중첩된 호출이 있는 경우 다음과 같습니다:

```
0 → Contract A (calls B) → 1 → Contract B (calls C) → 2 → Contract C (returns) → 1 → Contract B (returns) → 0
```

반면 **내부(Internal)** 함수는 호출 깊이를 증가시키지 **않습니다**. 실제로 _호출(calls)_ 을 하는 것이 아니라 대상 위치로 _점프(jumping)_ 하는 것입니다.

동일한 호출 깊이에서 `vm.expectRevert`로 **내부** 함수를 테스트할 때 **오직** **첫 번째** `vm.expectRevert`만 실행됩니다.

다음 예제는 실수가 발생하는 곳을 보여줍니다. 동일한 호출 깊이에 두 개의 `vm.expectRevert`가 존재하므로 **첫 번째** 것만 실행되고 테스트는 **성공(SUCCESS)** 을 반환합니다. 이는 아마도 여러분이 가정하는 동작과는 다를 것입니다.

```solidity
// 다음과 같이 구현하지 마십시오! 이것은 잘못된 사용입니다.
function testMultipleReverts() public {
    vm.expectRevert();
    revert();

    vm.expectRevert();
    console2.log("Does not revert");
}
```

### 설명

**다음 호출**이 예상 데이터 `message`로 되돌려지지 않으면(revert), `expectRevert`가 리버트됩니다.

> ⚠️ **사용법**
>
> 기본적으로 `expectRevert*` 치트코드는 테스트 깊이보다 더 깊은 호출에 대해서만 작동합니다 ([#3437](https://github.com/foundry-rs/foundry/issues/3437) foundry 이슈 참조).
> 테스트 깊이와 동일한 깊이에서 리버트를 예상하려면 다음과 같이 `allow_internal_expect_revert`를 `true`로 설정하여 활성화할 수 있습니다:
>
> **안전하다고 판단되는 경우** 인라인 구성 항목을 사용하여 선택적으로:
>
> 테스트 함수 위에 `/// forge-config: default.allow_internal_expect_revert = true`를 추가합니다.
>
> 또는 전역적으로 (권장되지 않음):
>
> `foundry.toml`에 `allow_internal_expect_revert = true`를 추가합니다.

단일 테스트 함수 본문에서 여러 내부 함수에 `vm.expectRevert`를 사용하지 않는 한 일반적으로 안전한 것으로 간주됩니다.

어셈블리 블록을 `memory-safe`로 태그할 때와 유사한 방식으로 이 규칙을 적용하는 것이 좋습니다.

> **참고**
>
> `stable.donate(sUSD.balanceOf(user))`와 같은 호출의 경우, 리버트될 것으로 예상되는 다음 호출은 `stable.donate()`가 아니라 `sUSD.balanceOf(user)`입니다.

`expectRevert`를 호출한 후, 리버트되는 호출 전의 다른 치트코드 호출은 무시됩니다.

즉, 예를 들어 리버트되는 호출 바로 전에 [`prank`](/reference/cheatcodes/prank.mdx)를 호출할 수 있습니다.

`expectRevert`에는 여러 서명이 있습니다:

- **매개변수 없음**: 메시지에 관계없이 다음 호출이 리버트됨을 어설션합니다.
- **`bytes4` 메시지**: 다음 호출이 지정된 4바이트 및 리버트 데이터의 정확한 일치로 리버트됨을 어설션합니다.
- **`bytes` 메시지**: 다음 호출이 지정된 바이트로 리버트됨을 어설션합니다.
- **`address` 리버터(reverter)**: 다음 호출이 지정된 주소에 의해 리버트됨을 어설션합니다.
- **`uint64` 횟수**: 다가오는 호출에서 정확한 횟수의 리버트를 예상합니다. 0으로 설정하면 리버트가 발생하지 않음을 어설션하는 데 사용할 수 있습니다.

그리고 `expectPartialRevert`에 대한 두 가지 서명이 있습니다:

- **`bytes4` 메시지**: 다음 호출이 리버트되고 지정된 4바이트가 리버트 데이터의 처음 4바이트와 일치함을 어설션합니다.
- **`bytes4` 메시지 및 리버터 `address`**: 다음 호출이 지정된 주소에 의해 리버트되고 지정된 4바이트가 리버트 데이터의 처음 4바이트와 일치함을 어설션합니다.

> ℹ️ **참고:**
>
> 사용자 정의 오류(Custom errors)는 때때로 테스트 환경에서 계산하기 어려운 인수를 가질 수 있거나 당면한 테스트와 관련이 없을 수 있습니다(예: 타사 컨트랙트의 내부 함수에서 계산된 값). 이러한 경우 `expectPartialRevert`를 사용하여 인수를 무시하고 사용자 정의 오류의 선택자(selector)에만 일치시킬 수 있습니다. 예를 들어, `WrongNumber(uint256 number)` 사용자 정의 오류로 리버트되는 함수를 테스트하는 경우:
>
> ```solidity
> function count() public {
>     revert WrongNumber(0);
> }
> ```
>
> `expectPartialRevert`를 사용하면 통과해야 합니다:
>
> ```solidity
> vm.expectPartialRevert(Counter.WrongNumber.selector);
> counter.count();
> ```
>
> 그러나 정확한 일치를 예상하면 실패합니다:
>
> ```solidity
> vm.expectRevert(Counter.WrongNumber.selector);
> counter.count();
> ```

> ⚠️ **주의: 저수준 호출(low-level calls)에서의 사용**
>
> 일반적으로 성공한 호출은 `true` 상태(반환 데이터와 함께)를 반환하고, 리버트된 호출은 `false`를 반환합니다.
>
> Solidity 컴파일러는 호출이 성공했는지 확인하고 그렇지 않으면 리버트하는 검사를 삽입합니다.
>
> 저수준 호출에서 `expectRevert` 치트코드는 저수준 호출에 의해 반환된 `status` 부울이 `expectRevert`의 성공 여부에 대응하도록 만듭니다. 저수준 호출의 성공 여부가 아닙니다. 따라서 `status`가 거짓인 것은 치트코드 실패에 해당합니다.
>
> 이 외에도 `expectRevert`는 저수준 호출의 반환 데이터를 엉망으로 만들므로 사용할 수 없습니다.
>
> 다음 예제를 참조하십시오. 명확성을 위해 `status`의 이름이 `revertsAsExpected`로 변경되었습니다:
>
> ```solidity
> function testLowLevelCallRevert() public {
>     vm.expectRevert(bytes("error message"));
>     (bool revertsAsExpected, ) = address(myContract).call(myCalldata);
>     assertTrue(revertsAsExpected, "expectRevert: call did not revert");
> }
> ```

### 예제

`expectRevert`를 `string`과 함께 사용하려면 문자열 리터럴로 전달하세요.

```solidity
vm.expectRevert("error message");
```

매개변수 없이 사용자 정의 [오류 타입][error-type]과 함께 `expectRevert`를 사용하려면 해당 선택자를 사용하세요.

```solidity
vm.expectRevert(CustomError.selector);
```

매개변수가 있는 사용자 정의 [오류 타입][error-type]과 함께 `expectRevert`를 사용하려면 오류 타입을 ABI 인코딩하세요.

```solidity
vm.expectRevert(
    abi.encodeWithSelector(CustomError.selector, 1, 2)
);
```

함수가 메시지 _없이_ 리버트됨을 어설션해야 하는 경우 `expectRevert(bytes(""))`로 수행할 수 있습니다.

```solidity
function testExpectRevertNoReason() public {
    Reverter reverter = new Reverter();
    vm.expectRevert(bytes(""));
    reverter.revertWithoutReason();
}
```

메시지 없는 리버트는 트랜잭션이 블록의 가스 제한보다 더 많이 소비하는 경우와 같이 EVM 오류가 있을 때 발생합니다.

함수가 4글자 메시지(예: `AAAA`)로 리버트됨을 어설션해야 하는 경우 다음과 같이 수행할 수 있습니다:

```solidity
function testFourLetterMessage() public {
    vm.expectRevert(bytes("AAAA"));
}
```

`expectRevert("AAAA")`를 사용하면 컴파일러가 어떤 오버로드를 사용할지 알 수 없으므로 오류가 발생합니다.

마지막으로, 단일 테스트에 여러 `expectRevert()` 검사를 가질 수도 있습니다.

```solidity
function testMultipleExpectReverts() public {
    vm.expectRevert("INVALID_AMOUNT");
    vault.send(user, 0);

    vm.expectRevert("INVALID_ADDRESS");
    vault.send(address(0), 200);
}
```

사용자 정의 [오류 타입][error-type]과 함께 `expectPartialRevert`를 사용하려면 해당 선택자를 사용하세요.

```solidity
vm.expectPartialRevert(CustomError.selector);
```

### 같이 보기

Forge 표준 라이브러리

[Std Errors](/reference/forge-std/std-errors.mdx)

[error-type]: https://docs.soliditylang.org/en/v0.8.11/contracts.html#errors
