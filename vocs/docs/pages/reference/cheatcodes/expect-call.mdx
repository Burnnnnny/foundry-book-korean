## `expectCall`

```solidity
function expectCall(address callee, bytes calldata data) external;
```

```solidity
function expectCall(address callee, bytes calldata data, uint64 count) external;
```

```solidity
function expectCall(
    address callee,
    uint256 value,
    bytes calldata data
) external;
```

```solidity
function expectCall(
    address callee,
    uint256 value,
    bytes calldata data,
    uint64 count
) external;
```

### 설명

지정된 주소 `callee`에 대한 호출을 예상하며, 호출 데이터는 `data`와 엄격하게 또는 느슨하게 일치해야 합니다. 치트코드는 두 가지 방식으로 호출할 수 있습니다:

- `count` 매개변수가 지정되지 않은 경우, 호출은 적어도 치트코드가 호출된 횟수만큼 이루어질 것으로 예상됩니다. 동일한 호출 데이터에 대해 `count` 없이 치트코드를 호출한 다음 `count` 매개변수를 전달할 수 없습니다.
- `count`가 지정된 경우, 호출은 엄격하게 `count` 횟수만큼 이루어질 것으로 예상됩니다. 동일한 호출 데이터에 대해 `count` 값을 다른 치트코드 호출로 덮어쓰거나, `count` 매개변수 없이 치트코드를 호출하여 증가시킬 수 없습니다.

`count`를 0으로 설정하여 호출이 이루어지지 않음을 어설션할 수도 있습니다.

`callee`에 대한 호출이 이루어지면 먼저 호출 데이터가 `data`와 전체적으로 일치하는지 확인합니다. 그렇지 않은 경우 호출 데이터에 부분적인 일치가 있는지 확인하며, 일치는 호출 데이터의 첫 번째 바이트부터 시작합니다.

**두 번째 서명을 사용하면** 호출이 예상된 `msg.value`로 이루어졌는지 확인할 수도 있습니다.

호출이 이루어지지 않고 테스트가 종료되면 테스트는 실패합니다.

> ℹ️ **내부 호출**
>
> 이 치트코드는 현재 내부 호출에서 작동하지 않습니다. 문제 [#432](https://github.com/foundry-rs/foundry/issues/432)를 참조하세요.

### 예제

토큰 `MyToken`에서 `transfer`가 한 번 호출될 것으로 예상:

```solidity
address alice = makeAddr("alice");
emit log_address(alice);
vm.expectCall(
  address(token), abi.encodeCall(token.transfer, (alice, 10))
);
token.transfer(alice, 10);
// [PASS]
```

토큰 `MyToken`에서 `transfer`가 *적어도* 두 번 호출될 것으로 예상:

```solidity
address alice = makeAddr("alice");
emit log_address(alice);
vm.expectCall(
  address(token), abi.encodeCall(token.transfer, (alice, 10))
);
vm.expectCall(
  address(token), abi.encodeCall(token.transfer, (alice, 10))
);
token.transfer(alice, 10);
token.transfer(alice, 10);
token.transfer(alice, 10);
// [PASS]
```

토큰 `MyToken`에서 `transfer`가 호출되지 않을 것으로 예상:

```solidity
address alice = makeAddr("alice");
emit log_address(alice);
vm.expectCall(
  address(token), abi.encodeCall(token.transfer, (alice, 10)), 0
);
token.transferFrom(alice, address(0), 10);
// [PASS]
```

토큰 `MyToken`에서 임의의 호출 데이터로 `transfer`가 2번 호출될 것으로 예상:

```solidity
address alice = makeAddr("alice");
emit log_address(alice);
vm.expectCall(
  address(token), abi.encodeWithSelector(token.transfer.selector), 2
);
token.transfer(alice, 10);
token.transfer(alice, 10);
// [PASS]
```

`Contract`에서 특정 `msg.value` 및 `calldata`로 `pay`가 호출될 것으로 예상:

```solidity
Contract target = new Contract();
vm.expectCall(
            address(target),
            1,
            abi.encodeWithSelector(target.pay.selector, 2)
        );
target.pay{value: 1}(2);
// [PASS]
```

`Contract`에서 특정 `msg.value` 및 `calldata`로 `pay`가 3번 호출될 것으로 예상:

```solidity
Contract target = new Contract();
vm.expectCall(
            address(target),
            1,
            abi.encodeWithSelector(target.pay.selector, 2),
            3
        );
target.pay{value: 1}(2);
target.pay{value: 1}(2);
target.pay{value: 1}(2);
// [PASS]
```
