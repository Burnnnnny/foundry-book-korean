## `signDelegation`

### 시그니처

```solidity
/// 권한 계정이 구현에 위임할 수 있는 서명된 EIP-7702 인증을 보유합니다.
struct SignedDelegation {
    // 복구된 secp256k1 서명의 y-패리티 (0 또는 1).
    uint8 v;
    // 서명의 첫 32바이트.
    bytes32 r;
    // 서명의 두 번째 32바이트.
    bytes32 s;
    // 서명 당시 권한 계정의 현재 논스.
    // 계정 논스가 변경된 후 서명이 재생되지 않도록 하는 데 사용됩니다.
    uint64 nonce;
    // 위임될 구현 컨트랙트의 주소.
    // 위임 코드로 인코딩됩니다: 0xef0100 || implementation.
    address implementation;
}
```

```solidity
/// 위임을 위한 EIP-7702 인증에 서명합니다.
function signDelegation(address implementation, uint256 privateKey)
    external
    returns (SignedDelegation memory signedDelegation);
```

```solidity
/// 다음 호출을 EIP-7702 트랜잭션으로 지정합니다.
function attachDelegation(SignedDelegation calldata signedDelegation) external;
```

```solidity
/// EIP-7702 인증에 서명하고 다음 호출을 EIP-7702 트랜잭션으로 지정합니다.
function signAndAttachDelegation(address implementation, uint256 privateKey)
    external
    returns (SignedDelegation memory signedDelegation);
```

### 설명

위임을 위한 [EIP-7702](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-7702.md) 인증에 서명합니다.

이 치트코드를 사용하려면 `foundry.toml`에서 `evm_version`을 최소 `prague` 하드포크로 설정해야 합니다.

```toml
evm_version = "prague"
```

EIP-7702는 위임 트랜잭션을 통해 EOA(외부 소유 계정)의 계정 코드를 설정하여 EOA가 스마트 컨트랙트처럼 동작할 수 있게 합니다.

`signDelegation` 치트코드는 위임할 구현 컨트랙트에 대한 서명된 인증을 생성하여 권한이 부여된 구현만 권한 계정을 대신하여 트랜잭션을 실행할 수 있도록 합니다. 서명에는 재생 공격을 방지하기 위해 권한 계정의 논스가 포함됩니다.

`attachDelegation` 치트코드는 서명된 인증을 첨부하여 다음 트랜잭션을 EIP-7702 위임으로 지정합니다.

`signAndAttachDelegation` 함수는 서명과 첨부를 한 단계로 결합하여 위임 프로세스를 단순화합니다.

### 예제

먼저 `SimpleDelegateContract`와 사용할 더미 `ERC20`을 정의해 봅시다:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract SimpleDelegateContract {
    event Executed(address indexed to, uint256 value, bytes data);

    struct Call {
        bytes data;
        address to;
        uint256 value;
    }

    function execute(Call[] memory calls) external payable {
        for (uint256 i = 0; i < calls.length; i++) {
            Call memory call = calls[i];
            (bool success, bytes memory result) = call.to.call{value: call.value}(call.data);
            require(success, string(result));
            emit Executed(call.to, call.value, call.data);
        }
    }

    receive() external payable {}
}

contract ERC20 {
    address public minter;
    mapping(address => uint256) private _balances;

    constructor(address _minter) {
        minter = _minter;
    }

    function mint(uint256 amount, address to) public {
        _mint(to, amount);
    }

    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    function _mint(address account, uint256 amount) internal {
        require(msg.sender == minter, "ERC20: msg.sender is not minter");
        require(account != address(0), "ERC20: mint to the zero address");
        unchecked {
            _balances[account] += amount;
        }
    }
}
```

다음으로 `forge test`에서 치트코드를 사용하는 방법입니다:

```solidity
contract SignDelegationTest is Test {
    // Alice의 주소와 개인 키 (초기 컨트랙트 코드가 없는 EOA).
    address payable ALICE_ADDRESS = payable(0x70997970C51812dc3A010C7d01b50e0d17dc79C8);
    uint256 constant ALICE_PK = 0x59c6995e998f97a5a0044966f0945389dc9e86dae88c7a8412f4603b6b78690d;

    // Bob의 주소와 개인 키 (Bob은 Alice를 대신하여 트랜잭션을 실행할 것입니다).
    address constant BOB_ADDRESS = 0x3C44CdDdB6a900fa2b585dd299e03d12FA4293BC;
    uint256 constant BOB_PK = 0x5de4111afa1a4b94908f83103eb1f1706367c2e68ca870fc3fb9a804cdab365a;

    // Alice가 실행을 위임할 컨트랙트.
    SimpleDelegateContract public implementation;

    // 테스트 토큰을 발행하기 위한 ERC-20 토큰 컨트랙트.
    ERC20 public token;

    function setUp() public {
        // 위임 컨트랙트 배포 (Alice는 이 컨트랙트에 호출을 위임할 것입니다).
        implementation = new SimpleDelegateContract();

        // Alice가 minter인 ERC-20 토큰 컨트랙트 배포.
        token = new ERC20(ALICE_ADDRESS);
    }

    function testSignDelegationAndThenAttachDelegation() public {
        // 단일 트랜잭션 호출 구성: Bob에게 100 토큰 발행.
        SimpleDelegateContract.Call[] memory calls = new SimpleDelegateContract.Call[](1);
        bytes memory data = abi.encodeCall(ERC20.mint, (100, BOB_ADDRESS));
        calls[0] = SimpleDelegateContract.Call({to: address(token), data: data, value: 0});

        // Alice는 `implementation`이 자신을 대신하여 트랜잭션을 실행할 수 있도록 허용하는 위임에 서명합니다.
        Vm.SignedDelegation memory signedDelegation = vm.signDelegation(address(implementation), ALICE_PK);

        // Bob은 Alice의 서명된 위임을 첨부하고 이를 브로드캐스트합니다.
        vm.broadcast(BOB_PK);
        vm.attachDelegation(signedDelegation);

        // Alice의 계정이 이제 스마트 컨트랙트처럼 동작하는지 확인합니다.
        bytes memory code = address(ALICE_ADDRESS).code;
        require(code.length > 0, "no code written to Alice");

        // Bob으로서 Alice의 할당된 컨트랙트를 통해 트랜잭션을 실행합니다.
        SimpleDelegateContract(ALICE_ADDRESS).execute(calls);

        // Bob이 성공적으로 100 토큰을 받았는지 확인합니다.
        assertEq(token.balanceOf(BOB_ADDRESS), 100);
    }

    function testSignAndAttachDelegation() public {
        // 단일 트랜잭션 호출 구성: Bob에게 100 토큰 발행.
        SimpleDelegateContract.Call[] memory calls = new SimpleDelegateContract.Call[](1);
        bytes memory data = abi.encodeCall(ERC20.mint, (100, BOB_ADDRESS));
        calls[0] = SimpleDelegateContract.Call({to: address(token), data: data, value: 0});

        // Alice는 한 단계로 위임에 서명하고 첨부합니다 (별도의 서명이 필요 없음).
        vm.signAndAttachDelegation(address(implementation), ALICE_PK);

        // Alice의 계정이 이제 스마트 컨트랙트처럼 동작하는지 확인합니다.
        bytes memory code = address(ALICE_ADDRESS).code;
        require(code.length > 0, "no code written to Alice");

        // Bob으로서 Alice의 할당된 컨트랙트를 통해 트랜잭션을 실행합니다.
        vm.broadcast(BOB_PK);
        SimpleDelegateContract(ALICE_ADDRESS).execute(calls);

        // Bob이 성공적으로 100 토큰을 받았는지 확인합니다.
        vm.assertEq(token.balanceOf(BOB_ADDRESS), 100);
    }
}
```

또는 `forge script`에서 `EIP-7702` 호환 Anvil 인스턴스에 대해 치트코드를 사용해 봅시다:

```sh
anvil --hardfork prague
```

다음으로 `forge script`에서 치트코드를 사용하려면:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract SignDelegationScript is Script {
    // Alice의 주소와 개인 키 (초기 컨트랙트 코드가 없는 EOA).
    address payable ALICE_ADDRESS = payable(0x70997970C51812dc3A010C7d01b50e0d17dc79C8);
    uint256 constant ALICE_PK = 0x59c6995e998f97a5a0044966f0945389dc9e86dae88c7a8412f4603b6b78690d;

    // Bob의 주소와 개인 키 (Bob은 Alice를 대신하여 트랜잭션을 실행할 것입니다).
    address constant BOB_ADDRESS = 0x3C44CdDdB6a900fa2b585dd299e03d12FA4293BC;
    uint256 constant BOB_PK = 0x5de4111afa1a4b94908f83103eb1f1706367c2e68ca870fc3fb9a804cdab365a;

    // 배포자의 주소와 개인 키 (컨트랙트 배포에 사용됨).
    address private constant DEPLOYER_ADDRESS = 0xa0Ee7A142d267C1f36714E4a8F75612F20a79720;
    uint256 private constant DEPLOYER_PK = 0x2a871d0798f97d79848a013d4936a73bf4cc922c825d33c1cf7073dff6d409c6;

    // Alice가 실행을 위임할 컨트랙트.
    SimpleDelegateContract public implementation;

    // 테스트 토큰을 발행하기 위한 ERC-20 토큰 컨트랙트.
    ERC20 public token;

    function run() external {
        // 1단계: 배포자의 키를 사용하여 위임 및 ERC-20 컨트랙트 배포.
        vm.broadcast(DEPLOYER_PK);
        implementation = new SimpleDelegateContract();
        token = new ERC20(ALICE_ADDRESS);

        // 단일 트랜잭션 호출 구성: Bob에게 100 토큰 발행.
        SimpleDelegateContract.Call[] memory calls = new SimpleDelegateContract.Call[](1);
        bytes memory data = abi.encodeCall(ERC20.mint, (100, BOB_ADDRESS));
        calls[0] = SimpleDelegateContract.Call({to: address(token), data: data, value: 0});

        // Alice는 `implementation`이 자신을 대신하여 트랜잭션을 실행할 수 있도록 허용하는 위임에 서명합니다.
        Vm.SignedDelegation memory signedDelegation = vm.signDelegation(address(implementation), ALICE_PK);

        // Bob은 Alice의 서명된 위임을 첨부하고 이를 브로드캐스트합니다.
        vm.broadcast(BOB_PK);
        vm.attachDelegation(signedDelegation);

        // Bob으로서 Alice의 할당된 컨트랙트를 통해 트랜잭션을 실행합니다.
        SimpleDelegateContract(ALICE_ADDRESS).execute(calls);

        // 잔액 확인
        vm.assertEq(token.balanceOf(BOB_ADDRESS), 100);
    }
}
```

스크립트 실행:

```sh
forge script script/SignDelegation.s.sol --rpc-url http://localhost:8545 --broadcast
```
